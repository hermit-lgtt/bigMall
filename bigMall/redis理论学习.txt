redis的高可用——分布式系统——单点故障->多台机器->主从模式、哨兵模式、集群模式
部署多台机器->不同机器的数据同步，要复制相同的数据给到其他机器，同步/异步
redis多机器部署->主节点(master节点)、从节点(slave节点)，主节点负责读写，从节点负责读，一主多从
私下学习一般在一台虚拟机里面开多个系统，分别有不同的ip，端口相同就可以
首先，配置主节点和从节点，redis.conf文件指定主节点的ip和端口
其次，先启动主节点、再一台一台启动从节点，
同步数据，首先从节点发送SYNC请求，主节点创建快照RDB、缓冲快照生成期间的写命令，
主节点发送快照给从节点，从节点载入、解析快照，并把之前的旧数据丢掉，在此期间，主服务器要缓冲快照同步期间的写命令
然后，主节点再把这个写缓冲给同步到从节点，从节点载入缓冲。如果出现了断开重连，就进行增量复制，包括主从刚连接时候，也是直接进行全量同步

那如果主服务器宕机了呢，要手动切换服务器-->一段时间内不可用-->哨兵模式，master宕机，哨兵会自动选举master，将其他的slave指向新的master-->通过发布订阅模式，用其他的从服务器修改配置文件，让它们切换主机
哨兵是一个独立的进程，redis-sentinel哨兵命令，哨兵进程向所有的redis机器发送命令，等待Redis服务器响应，从而响应多个Redis实例，哨兵也可以有多个，一般奇数个
哨兵比较像kafka的zookeeper
配置哨兵模式改的是sentinel.conf，不用改redis.conf
sentinel monitor mymaster 192.168.1.15 6379 2//2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作,就故障转移。

发送ping命令，超过down-after-milliseconds时间，这个实例会被Sentinel哨兵主观下线
其他哨兵也对这个主服务器进行检测，每秒一次，足够数量，主观下线变成客观下线

假设master宕机，sentinel 1先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的master，仅仅是sentinel 1主观的认为master不可用，
这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由sentinel 1发起，进行 failover 操作。
切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的
缺点：每台机器的数据是一样的，内存可用性很低，很难支持在线扩容(集群容量达到上线

集群模式-->slots哈希槽，Redis的分布式存储，Cluster集群模式，对数据进行分片，每台Redis节点上存储不同的内容，三主三从
对客户端来说，整个cluster集群是一个整体的，客户端可以连接任何一个node进行操作，像操作单个Redis实例一样
6台redis两两之间并不是独立的，每个节点都会通过集群总线(cluster bus)，与其他的节点进行通信。通讯时使用特殊的端口号，即对内端口号是对外服务端口号加10000

修改redis.conf ->cluster-enabled yes 开启集群模式
使用redis-tri.rb工具，创建集群
登录集群：redis-cli -c -h 192.168.1.11 -p 6379 -a 123456 # -c，使用集群方式登录。
查看集群信息：192.168.1.11:6379> CLUSTER INFO #集群状态
列出节点信息：192.168.1.11:6379> CLUSTER NODES #列出节点信息
运行机制：在一个redis的每一个节点上，有两个东西，一个是slot，一个是cluster，前者是哈希槽0-16383，从redis-trib.rb看16383个slot在三个主服务器的分布，
后者是集群管理的插件，类似哨兵

取得key，用crc16算法，得到结果，用结果和16384求余，每个key就会对应编号0-16383之间的哈希槽，然后找到对应的哈希槽的对应的节点，在这个节点上面进行存取操作
心跳机制，网络传输
集群设计最多支持1000个分片，1000个master，每个master也有足够的哈希槽，将插槽配置为原始的位图传播
bitmap

分布式锁，不能用jvm提供的同步锁了，这个只在一个机器内保证数据访问的一致性，如果两个一样的请求到后端服务器，可能会被分发到两个tomcat上面，synchronized就会失效

分布式锁要解决的是多机器部署，相同请求并发访问时候的资源竞争问题，请求到达每个tomcat时候，首先邀请redis中注册锁，注册成功就返回true说明获得了锁
原生的redis client的api，，SET anyLock unique_value NX PX 30000
开源框架Redisson

Config =config = new Config();
config.useClusterServices()
        .addNodeAddress("redis://192.168.1.30:9211")
        .addNodeAddress("redis://192.168.1.30:9212")
        .addNodeAddress("redis://192.168.1.30:9213")
        .addNodeAddress("redis://192.168.1.30:9214")
        .addNodeAddress("redis://192.168.1.30:9215")
RedissonClient redisson = Redisson.create(config);
RLock lock = redisson.getLock("anyLock");
lock.lock();
....业务代码...
lock.unlock();

redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行
redisson设置一个key的默认过期时间为30s,如果某个客户端持有一个锁超过了30s，怎么办呢
redisson中有一个watchdog看门狗的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间设为30s
这样的话，就算一直持有锁也不会出现key过期了，其他线程获取到锁的问题，redisson的"看门狗"逻辑保证了没有死锁发生
因为如果机器宕机了，看门狗也没了，也就不会延长key的过期时间，到了30s就会自动过期
其他线程获取锁

redlock算法

可重入锁RLock，实现了Lock接口

多个进程必须以互斥的方式独占共享资源-->分布式锁
